# GIT 직접 써보기

Git은 회사에서 개발 과정을 효과적으로 정리하기 위해서 필수에요. 깃은 여러 개발자가 하나의 프로젝트에 서로 영향을 주지 않으며 동시 작업할 수 있도록 도와줘요. 이건 깃의 브랜칭(Branching)과 머징(Merging) 기능 덕분인데, 코드 변경의 히스토리를 모두 관리해요. 만약 수정한 코드가 올바르게 동작하지 않는다면 동작하던 코드로 쉽게 돌아갈 수 있으며, 서로 다른 기능을 개발해서 한 곳으로 합치는 작업도 할 수 있죠.

## 이 리포지토리에 대해서
이 리포지토리는 깃을 실제로 사용하는 것처럼 연습을 해볼 수 있게 만들었어요. 서로 다른 파일을 추가하면 최종적으로 코드베이스에 수정을 할 때 필연적으로 merge conflict를 겪게 되는데, 이 merge conflict를 직접 경험하고 해결할 수 있어야해요. 그런 과정에서 자연스럽게 브랜치도 생성해보고, PR(Pull Request)도 직접 수행해보면 좋겠습니다.

## 리포지토리 사용방법
1. 우선 이 리포지토리를 편한 곳으로 클론해주세요.
```bash
git clone https://github.com/lee-jangwon/practice_git.git
```

2. 클론을 수행하신 장소에 `practice_git`이라는 디렉터리가 생겼을거예요. 그 폴더로 들어가볼게요.
```bash
cd practice_git
```

3. 이제 브랜치를 만들어볼게요.
브랜치는 메인 코드 베이스에 영향을 주지 않으면서 새로운 기능을 개발할 수 있게 해줘요.
```bash
git checkout -b new_branch # 여기는 feature/jangwon-branch 처럼 누구 브랜치인지 알 수 있게 해주세요
```

위 명령어를 자세하게 알아볼까요? checkout은 원래 브랜치를 변경할 때 사용되는 명령언데, 뒤에 `-b` 플래그를 더하므로 새로운 브랜치를 만들어서 새롭게 생성된 브랜치로 스위칭을 해줘요. `new_branch`는 제가 그냥 임의로 사용한 브랜치 명이지만 저희는 Git Convention이 있어서 해당 문서를 참조해서 브랜치명을 작성하시면 됩니다.

4. 브랜치 작업
브랜치가 성공적으로 생성되었다면 별로 달라진건 없을거예요. 대신 아래 명령어로 새로 브랜치가 생성된것을 확인할 수 있어요.
```bash
git branch
```

처음 클론을 했으면 아마 `main` 브랜치가 활성화 되어 있었을 거예요. 하지만 방금 `git checkout -b new_branch` 명령으로 새로운 브랜치를 만들고 그 브랜치로 이동했기 때문에 `feature/jangwon-branch`가 아마 활성화 되어 있을거예요.

이제 이 상태에서 작업을 하는 코드는 메인 코드베이스에 아무런 영향을 끼치지 않아요. 파일을 삭제하거나 말도 안 되는 코드를 써도 메인 코드베이스는 안전하죠.

이 상태에서 이 리포지토리에 있는 `playground.md`를 수정해보세요. `merge conflict`는 여러 개발자가 동일한 라인의 코드를 수정하려고 할 때 발생해요. 예를 가상의 `test.py` 파일 10번줄에 있는 `print`문을 개발자 A가 수정했는데 개발자 B가 삭제한다면 깃은 이를 어떻게 해결해야할지 물어볼거예요. 이때 발생하는걸 `merge conflict`라고 하고, 이 문제를 해결하는걸 `resolving merge conflict`라고 해요.

머지 컨플릭트를 해결하는 방법은 간단해요. 

깃이 컨플릭트가 난 코드를 `<<<<`와 `>>>>`로 감싸서 표시해줄거예요. 직접 수정한 코드는 위에 보여질거고, 머지하려고 하는 브랜치의 코드가 아래에 표시될거예요. 이때 위 아래에 있는 코드를 비교해보고 더 적합한 코드를 선택(또는 병합)한 후, 깃이 자동으로 생성한 주석을 삭제하고 다시 커밋하면 컨플릭트 없이 코드를 올릴 수 있어요.